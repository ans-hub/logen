#!/bin/bash
# Mosh generator (MoshGen) - perfom generating data like logs
# Usage description: see fx_usage()
# Style guide: https://google.github.io/styleguide/shell.xml

function fx_usage()
{

  echo "Usage: moshgen [options]... [date_start] [date_end]
  
  Main flags:
    -s (--step-sec)         - step in seconds to iterate dates
    -d (--date-format)      - output date format in \$(date) format
    -m (--mosh-fields)      - mosh fields count, mosh date field, field
                              length and delimetr in "%d,%d,%d,%s" format
    -o (--output)           - file name of output file (optional)
    -b (--output-debug)     - show debug info (optional)
  
  Date flags:
    - set in any format recognized by \$(date) command
  
  Examples:
    - moshgen -m "12,3,50,\040" (\040 - space)
    " \
  | sed 's/^\s\s//' 1>&2
  
  exit 1
}

function sys_error()
{
  [[ $@ ]] && echo "error: $@" >&2
  critical_error_flag="1"
}

function sys_debug()
{
  [[ "${DEBUG}" == 'true' ]] && echo -e "debug: $@" >&2
}

function sys_is_abort()
{
  [[ $critical_error_flag == '1' ]] && echo "exit" && exit 1
}

function fx_define_vars()
{
  critical_error_flag=''
  
  DEBUG='false'
  
  DATE_START=''
  DATE_END=''

  DATE_FORMAT=''
  DATE_STEP=0

  OUTPUT_FNAME=''

  MOSH_FIELDS=''
}

function fx_define_const()
{
  readonly DEBUG
  
  readonly DATE_START
  readonly DATE_END

  readonly DATE_FORMAT
  readonly DATE_STEP

  readonly MOSH_FIELDS
}

function fx_getopts
{

  local OPTIND \
        flag

  # Step 1: Iterate throught arguments for getting main options

  while getopts "bhs:d:o:m:" flag
  do
    case "${flag}" in
      
      b) DEBUG='true' ;;

      s) DATE_STEP=${OPTARG} ;;
      d) DATE_FORMAT="${OPTARG}" ;;
      o)
         OUTPUT_FNAME="${OPTARG}"
         truncate --size 0 $OUTPUT_FNAME >&2 || sys_error 'Option -o - can`t write test file'
         ;;
      m) MOSH_FIELDS="${OPTARG}"
         [[ $(grep -o "," <<< "${MOSH_FIELDS}" | wc -l) != 3 ]] && sys_error 'Option -m failed'
         ;;

      h) fx_usage ;;
      ?) sys_error ;;

    esac
  done
  
  sys_debug "script parametrs: $*";

  # Step 2: Iterate throught arguments for getting dates

  shift "$((OPTIND-1))"

  [[ ! -z $1 ]] && DATE_START=$1
  [[ ! -z $2 ]] && DATE_END=$2
}

function fx_check_required_options()
{

  [[ -z $DATE_STEP ]] && sys_error 'Option -s is required'
  [[ -z $DATE_FORMAT ]] && sys_error 'Option -d is required'
  [[ -z $DATE_FORMAT ]] && sys_error 'Option -o is required'
  [[ -z $MOSH_FIELDS ]] && sys_error 'Option -m is required'
  [[ -z $DATE_START ]] && sys_error '$1 as date_start is required'
  [[ -z $DATE_END ]] && sys_error '$2 as date_end is required'

}

function fx_check_dates_format()
{
  sys_debug "Date start: ${DATE_START}"
  date -d "$DATE_START" > /dev/null 2>&1
  [[ $(echo $?) != 0 ]] && sys_error 'Start date format is not recognized'
    
  sys_debug "Date end: ${DATE_END}"
  date -d "$DATE_END" > /dev/null 2>&1
  [[ $(echo $?) != 0 ]] && sys_error 'End date format is not recognized'

}

function fx_form_mosh()
{

  local i \
        fields_cnt \
        fields_len \
        fields_sep \
        field_data \
        side
  
  # Split array

  IN="${MOSH_FIELDS}"
  arrIN=(${IN//,/ })
  
  # Access array - echo 
  
  fields_cnt="${arrIN[0]}"
  fields_dat="${arrIN[1]}"
  fields_len="${arrIN[2]}"
  fields_sep="${arrIN[3]}"

  # Form temp string
  
  field_data=$(echo \
  $(for ((i=1;i<=${fields_len};i++))
    do
      printf '%s' "${RANDOM:0:1}"
    done
    )
  )
  
  # Form side string

  if [[ "$1" == 'left' ]]; then

    for ((i=1; i<${fields_dat};i++)); do
      printf "${i}${field_data}${fields_sep}"
    done
  
  else

    for ((i=$(((${fields_dat}+1))); i<=${fields_cnt};i++)); do
      printf "${fields_sep}${i}${field_data}"
    done

  fi

}

function fx_compare_fileoutput()
{

  local iter_curr \
        iter_end \
        loop_cnt \
        output_file \
        items_total \
        i

  # Set dates in unix timestamp format for iterate

  iter_curr=$(date -d "$(date -d "$DATE_START" +%Y-%m-%d)" +%s)
  iter_end=$(date -d "$(date -d "$DATE_END" +%Y-%m-%d)" +%s)

  # Set first time output file

  output_file=${OUTPUT_FNAME}_$(date -d "@${iter_curr}" +%Y-%m-%d)
  touch -t "$(date -d "@${iter_curr}" +%Y%m%d)0000" ${output_file}

  # Prepare vars for defining end of day

  i=0
  items_total=0
  loop_cnt=$(((86400/${DATE_STEP})))  # how many steps in day

  # Iterate

  while [[ $iter_curr -le $iter_end ]]; do

    # If new day is started

    if [[ $i -ge $loop_cnt ]]; then
      sys_debug "Added ${items_total} items to ${output_file}"  
      i=0
      output_file=${OUTPUT_FNAME}_$(date -d "@${iter_curr}" +%Y-%m-%d)
      touch -t "$(date -d "@${iter_curr}" +%Y%m%d)0000" ${output_file}
    fi
    
    # Output current record

    echo "${1}$(date -d "@$iter_curr" ${DATE_FORMAT})$2" >> $output_file

    # System counters

    ((i++))
    ((items_total++))
    ((iter_curr=$iter_curr+$DATE_STEP))

  done

}
 
function fx_compare_stdout()
{
  local iter_curr \
        iter_end

  iter_curr=$(date -d "$(date -d "$DATE_START" +%Y-%m-%d)" +%s)
  iter_end=$(date -d "$(date -d "$DATE_END" +%Y-%m-%d)" +%s)

  while [[ $iter_curr -le $iter_end ]]; do
    echo "${1}$(date -d "@$iter_curr" ${DATE_FORMAT})$2"
    ((iter_curr=$iter_curr+$DATE_STEP))
  done

}

function main()
{

  local mosh_left \
        mosh_right

  fx_define_vars
  fx_getopts "$@"
  fx_define_const

  fx_check_required_options
  sys_is_abort

  fx_check_dates_format
  sys_is_abort
  
  mosh_left="$(fx_form_mosh "left")"
  mosh_right="$(fx_form_mosh "right")"
  
  if [[ -n ${OUTPUT_FNAME} ]]; then
    fx_compare_fileoutput "$mosh_left" "$mosh_right"
  else
    fx_compare_stdout "$mosh_left" "$mosh_right"
  fi

}

main "$@"