#!/bin/bash
# Mosh generator (MoshGen) - perfom generating data like logs
# Usage description: see fx_usage()
# Style guide: https://google.github.io/styleguide/shell.xml

function fx_usage()
{

  echo "Usage: $0 [options]... [date_start] [date_end]
  
  Main flags:
    -s (--step-sec)         - step in seconds to iterate dates
    -d (--date-format)      - output date format in \$(date) format
    -o (--output)           - file name of output file
    -e (--each-per-day)     - write each file per, add prefix to -o

    -b (--output-debug)     - debug data destination (optional)
  
  Date flags:
    - set in any format recognized by \$(date) command
    " \
  | sed 's/^\s\s//' 1>&2
  
  exit 1
}

function sys_error()
{
  [[ $@ ]] && echo "error: $@" >&2
  critical_error_flag="1"
}

function sys_debug()
{
  [[ "${DEBUG}" == 'true' ]] && echo -e "debug: $@" >&2
}

function sys_is_abort()
{
  [[ $critical_error_flag == '1' ]] && echo "exit" && exit 1
}

function fx_define_vars()
{

  critical_error_flag=''
  
  DEBUG='false'
  
  DATE_START=''
  DATE_END=''

  DATE_FORMAT=''
  DATE_STEP=''

  OUTPUT_FNAME=''
  OUTPUT_EACH='false'

}

function fx_define_const()
{
  readonly DEBUG
  
  readonly DATE_START
  readonly DATE_END

  readonly DATE_FORMAT
  readonly DATE_STEP

  readonly OUTPUT_EACH
}

function fx_getopts
{

  local OPTIND \
        flag

  # Step 1: Iterate throught arguments for getting main options

  while getopts "bhs:d:o:e" flag
  do
    case "${flag}" in
      
      b) DEBUG='true' ;;

      s) DATE_STEP="${OPTARG}" ;;
      d) DATE_FORMAT="${OPTARG}" ;;
      o)
         OUTPUT_FNAME="${OPTARG}"
         truncate --size 0 $OUTPUT_FNAME >&2 || sys_error 'Option -o - can`t write test file'
         ;;
        
      e) OUTPUT_EACH='true' ;;

      h) fx_usage ;;
      ?) sys_error ;;

    esac
  done
  
  sys_debug "script parametrs: $*";

  # Step 2: Iterate throught arguments for getting dates

  shift "$((OPTIND-1))"

  [[ ! -z $1 ]] && DATE_START=$1
  [[ ! -z $2 ]] && DATE_END=$2
}

function fx_check_required_options()
{

  [[ -z $DATE_STEP ]] && sys_error 'Option -s is required'
  [[ -z $DATE_FORMAT ]] && sys_error 'Option -d is required'
  [[ -z $DATE_FORMAT ]] && sys_error 'Option -o is required'
  [[ -z $DATE_START ]] && sys_error '$1 as date_start is required'
  [[ -z $DATE_END ]] && sys_error '$2 as date_end is required'

}

function fx_check_dates_format()
{
  sys_debug "Date start: ${DATE_START}"
  date -d "$DATE_START" > /dev/null 2>&1
  [[ $(echo $?) != 0 ]] && sys_error 'Start date format is not recognized'
    
  sys_debug "Date end: ${DATE_END}"
  date -d "$DATE_END" > /dev/null 2>&1
  [[ $(echo $?) != 0 ]] && sys_error 'End date format is not recognized'

}

function fx_compare_timestamps()
{

  local i \
        time_st \
        time_en \
        iter_start \
        iter_curr \
        iter_end \
        record

  # Define iteratable dates variables
  
  iter_curr=$(date -d "$DATE_START" +%s)
  iter_end=$(date -d "$DATE_END" +%s)

  # Iterate throught dates

  i=0
  while [[ $iter_curr -le $iter_end ]]; do
    
    date_curr=$(date -d "@$iter_curr" "$DATE_FORMAT")
    record="mosh_Data ${date_curr} mosh_Data [data] as_mosh_data"
    
    if [[ ! -n $OUTPUT_FILE ]]; then
      echo $record
    else
      echo $record >> $OUTPUT_FILE
    fi
    
    ((iter_curr=$iter_curr+$DATE_STEP))
    sys_debug "$((i++)) - ${date_curr}"
    
  done
}

function fx_sec2time() {
  local h \
        m \
        s
  ((h=${1}/3600))
  ((m=(${1}%3600)/60))
  ((s=${1}%60))
  printf "%02d:%02d:%02d\n" $h $m $s

}

function fx_compare_alt()
{

  local output_file \
        items \
        records

  loop_start="$(date -d "${DATE_START}" "+%Y-%m-%d")"
  loop_end="$(date -d "${DATE_END}" "+%Y-%m-%d")"

  # Iterate throught days

  items=0
  loop_curr=$loop_start

  while [[ "$loop_curr" != "$loop_end" ]]; do

    # Form next date string

    loop_curr=$(date -d "${loop_curr} + 1 days" "+%Y-%m-%d")
    
    # Add prefix to $OUTPUT_FNAME if -e option is here

    if [[ $OUTPUT_EACH == 'true' ]]; then
      output_file=${OUTPUT_FNAME}_$(date -d "${loop_curr}" +%Y-%m-%d)
    else
      output_file=${OUTPUT_FNAME}
    fi

    sys_debug "Writing output into ${output_file}"

    # Inside each day loop seconds with step

    m=0

    while [[ m -le 86400 ]]; do
      
      record="mosh_Data ${loop_curr}_$(fx_sec2time "${m}") mosh_Data"
      
      if [[ -n $output_file ]]; then
        echo $record >> $output_file
      else
        echo $record
      fi
      
      (( items++))
      (( m = m + ${DATE_STEP} ))

    done

    # Change modification time to current_loop

    [[ -n $output_file ]] && touch -t "$(date -d "${loop_curr}" +%Y%m%d)0000" ${output_file}

    sys_debug "Items added: ${items}"
    sleep 3;

  done

}

function main()
{

  fx_define_vars
  fx_getopts "$@"
  fx_define_const

  fx_check_required_options
  sys_is_abort

  fx_check_dates_format
  sys_is_abort

  # fx_compare_timestamps
  fx_compare_alt

}

main "$@"

# awk
# input:  %Y:_%D-%M__%h%m_%s. 
# split [1] "%Y"; [2] ":"; [3] "%D"; ...
# next_date in %Y_%m_%D format
# copy arr
# fill arr
# foreach
#   string $1$2$3.. count of arr
# output: 2017:_02-Nov_2132_33
# 
# iterate date in any format (date +%Y%D%M)
# iterate time in seconds
# array[Y]

# input:  %Y:_%D-%M__%h%m_%s
# if %Y, then replace %04d, else %02d; etc. %b %B ...
# $output_format: print (%04d:_%02d-%02d__%02d%02d_%02d)
#
# split format
# replace %b %B to %m
# $output_consider: [1] y [2] m [3] d [4] H [5] M [6] S
#
# input vars: y=2017 ; m=02 ; d=22; H=22; M=21; S=22
# printf ($output_format) $1 $2 $3 $4 $5 $6
#
# %Y - %04d
# %y %m %H %M %S - %02d
# %B - %s
# %b - %s
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
